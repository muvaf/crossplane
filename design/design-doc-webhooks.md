# Webhooks in Crossplane

## Use Cases

Let's list all the known issues that can be solved by using webhooks and with which operation type.

* Conversion webhooks for version changes in CRDs #1584
  * Mutation in `CREATE`, `UPDATE` operation of **all kinds**
* Validate composition base templates #1476
  * Validation in `CREATE` operation of `Composition`
* Validate schemas in XRD #1752
  * Validation in `CREATE` operation of `CompositeResourceDefinition`
* Immutable resource fields #727
  * Validation in `UPDATE` operation of **every managed resource**
  * The semantics in the KEP covering this is `can-be-set-only-in-creation` while what we want `cannot-be-changed-once-set`. So we can't really use upstream impl. when it's implemented.
* Composition scheduling #967
  * Mutation in `CREATE` operation of `Composition`
* Support `oneOf` semantics validation for discriminator fields #950
  * Implemented in Kubernetes, coming to controller-runtime.

## Implementation Requirements

As we can see, there are multiple use cases each requiring different levels of customizations. While we want to streamline webhook implementation by providing abstractions, we need to allow granular customizations to cover these cases. The following list is roughly what we can start with as configurable:

* Mutation/Validation webhook types.
* `CREATE` and `UPDATE` operation types.
* Static kind specification.
  * Dynamic kind specification would be useful for XRD-defined kinds, though it's a nice-to-have rather than a goal for now.

For the use cases that work with statically defined types like `Composition`, we can use lower level abstractions if necessary since they are implemented only once. So, we want to optimize our abstraction for the ones that require per-kind implementaton: immutable fields, conversion webhooks.

### Immutable Fields

This problem can be solved by a generic implementation that takes a list of field paths per kind, which can either be specified manually or generated by a tool scanning for a specific marker in API type file. I believe our existing `fieldpath` package in `crossplane-runtime` would be very handy here. So, we will have a separate Go implementation for this use case that may or may not use the abstraction we define.

### Conversion Webhooks

The main essence of conversion webhook problem is essentially field matching and doing transforms in-between. These operations are not very complex but they are also hard to generalize for every kind of CRDs we have. Specifically, when a new version of provider API that has breaking changes is released, we can't really guess how complex the conversion process will be. That's why we want to give code-level flexibility to owners of the CRDs while keeping the webhook mechanics that are general be handled automatically by our abstraction layer.

## Proposal

### Upstream Tools

There are two main mechanisms that upstream provides:
* Kubebuilder automatically generates webhook registration YAMLs for the marked structs.
* `controller-runtime` provides two abstraction layers.
  * Low level `mgr.GetWebhookServer().Register(path string, hook http.Handler)`.
  * High level `Defaulter` and `Validator` interfaces.

Kubebuilder generating YAMLs would work for us; it's designed similar to CRD generation and fairly simple. But we need to look at the abstractions `controller-runtime` provides a little deeper.

[Mutation](https://github.com/kubernetes-sigs/controller-runtime/blob/0208f43/pkg/webhook/admission/defaulter.go#L28) webhook:
```golang
// Defaulter defines functions for setting defaults on resources
type Defaulter interface {
	runtime.Object
	Default()
}
```

[Validation](https://github.com/kubernetes-sigs/controller-runtime/blob/8161d1c/pkg/webhook/admission/validator.go#L30) webhook:
```golang
// Validator defines functions for validating an operation
type Validator interface {
	runtime.Object
	ValidateCreate() error
	ValidateUpdate(old runtime.Object) error
	ValidateDelete() error
}
```

We see that the interfaces include `runtime.Object`, which means the functions need to be members of the kinds, i.e. `RDSInstance` struct needs to implements these functions. The abstraction layer that accepts these interfaces look pretty similar so I'll copy only the mutation one:

```golang
// Handle handles admission requests.
func (h *mutatingHandler) Handle(ctx context.Context, req Request) Response {
	if h.defaulter == nil {
		panic("defaulter should never be nil")
	}

	// Get the object in the request
	obj := h.defaulter.DeepCopyObject().(Defaulter)
	err := h.decoder.Decode(req, obj)
	if err != nil {
		return Errored(http.StatusBadRequest, err)
	}

	// Default the object
	obj.Default()
	marshalled, err := json.Marshal(obj)
	if err != nil {
		return Errored(http.StatusInternalServerError, err)
	}

	// Create the patch
	return PatchResponseFromRaw(req.Object.Raw, marshalled)
}
```

This high level abstraction layer doesn't really work for us because:
* It requires implementation in API type packages but conversion logic for a managed resource CRD will likely need to import provider SDK, which is something we don't want to do because it forces external users of API types to import them as well.
* `Default` is not a well-suited name for our conversion operation.

On the other hand, while the low level one would work, we never really need to customize encoder/decoders and deal with `http.Handler` interface. The following section proposes an abstraction layer built on top of this lower level one.

### Proposed Abstraction

